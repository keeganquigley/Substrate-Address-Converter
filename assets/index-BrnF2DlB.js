import{y as ce,C,F as J,G as pe,z as j,H as U,D as ne,A as Re,K,J as Ze,L as Pn,T as fe,O as G,R as rt,S as w,V as b,E as B,_ as p,M as E,N as X,x as Vt,P as Ln,Q as ot,a8 as Me,U as ye,a9 as ct,aa as at,ab as Mn,W as Nt,X as Cn,Y as $n,ac as On,ad as Vn,Z as Rt,$ as Ht,a0 as Wt,a1 as Ft,a2 as qt,a3 as jt,a4 as zt,a5 as Kt}from"./index-ChSEz4ri.js";const Et=(e,t)=>e.type==="array"&&e.len===t&&e.value.type==="primitive"&&e.value.value==="u8",se={type:"void"},Nn=(e,t=()=>null)=>{const n=new Map,s=new Set,r=h=>m=>{let l=n.get(m);if(l)return l;if(s.has(m)){const y={id:m};return n.set(m,y),y}s.add(m);const u=h(m);return l=n.get(m),l?Object.assign(l,u):(l={id:m,...u},n.set(m,l)),s.delete(m),l};let o=!0,c=!0;const a=r(h=>{const m=t(e[h]);if(m)return m;const{def:l,path:u,params:y}=e[h];if(l.tag==="composite"){if(l.value.length===0)return se;if(l.value.length===1){const f=a(l.value[0].type);return o&&u.at(-1)==="AccountId32"&&Et(f,32)?(o=!1,{type:"AccountId32"}):c&&u.at(-1)==="AccountId20"&&Et(f,20)?(c=!1,{type:"AccountId20"}):f}return d(l.value)}if(l.tag==="variant"){if(u.length===1&&u[0]==="Option"&&y.length===1&&y[0].name==="T"){const I=a(y[0].type);return I.type==="void"?{type:"primitive",value:"bool"}:{type:"option",value:I}}if(u.length===1&&u[0]==="Result"&&y.length===2&&y[0].name==="T"&&y[1].name==="E")return{type:"result",value:{ok:a(y[0].type),ko:a(y[1].type)}};if(l.value.length===0)return se;const f={},v={};return l.value.forEach(I=>{const O=I.name;if(v[O]=I.docs,I.fields.length===0){f[O]={...se,idx:I.index};return}if(I.fields.length===1&&!I.fields[0].name){f[O]={type:"lookupEntry",value:a(I.fields[0].type),idx:I.index};return}f[O]={...d(I.fields),idx:I.index}}),{type:"enum",value:f,innerDocs:v}}if(l.tag==="sequence")return{type:"sequence",value:a(l.value)};if(l.tag==="array"){const{len:f}=l.value,v=a(l.value.type);return!f||v.type==="void"?se:f>1?{type:"array",value:v,len:l.value.len}:v}if(l.tag==="tuple")return l.value.length===0?se:l.value.length>1?i(l.value.map(f=>a(f)),l.value.map(f=>e[f].docs)):a(l.value[0]);if(l.tag==="primitive")return{type:"primitive",value:l.value.tag};if(l.tag==="compact"){const f=a(l.value);return f.type==="void"?se:{type:"compact",isBig:Number(f.value.slice(1))>32,size:f.value}}return{type:l.tag,isLSB:(e[l.value.bitOrderType].path.at(-1)??"LSB").toUpperCase().startsWith("LSB")}}),d=h=>{let m=!0;const l={},u={};return h.forEach((y,f)=>{m=m&&!!y.name;const v=y.name||f,I=a(y.type);I.type!=="void"&&(l[v]=I,u[v]=y.docs)}),m?{type:"struct",value:l,innerDocs:u}:i(Object.values(l),Object.values(u))},i=(h,m)=>{if(h.every(l=>l.id===h[0].id)&&m.every(l=>!l.length)){const[l]=h;return l.type==="void"?se:{type:"array",value:h[0],len:h.length}}return{type:"tuple",value:h,innerDocs:m}};return a},Gt=e=>{const t=Nn(e.lookup,({def:r})=>{if(r.tag==="composite"){const o=n(r);if(o)return{type:"enum",innerDocs:{},value:Object.fromEntries(e.pallets.map(c=>[c.name,c.errors==null?{...se,idx:c.index}:{type:"lookupEntry",value:t(c.errors.type),idx:c.index}])),byteLength:o}}return null});function n(r){if(!(r.value.length===2&&r.value[0].name==="index"&&r.value[1].name==="error"))return null;const c=t(r.value[0].type),a=t(r.value[1].type);return c.type==="primitive"&&c.value==="u8"&&a.type==="array"&&a.value.type==="primitive"&&a.value.value==="u8"?1+a.len:null}return Object.assign(t,{metadata:e,call:"call"in e.extrinsic?e.extrinsic.call:e.lookup[e.extrinsic.type]?.params.find(c=>c.name==="Call")?.type??null})},g=ce(C,e=>e,Number),Yt=ce(C,e=>e,BigInt),Rn=pe(e=>{const t=g.dec(e),n=Math.ceil(t/8);return{bytes:j(n).dec(e),bitsLen:t}}),Hn=e=>{if(e.bitsLen>e.bytes.length*8)throw new Error(`Not enough bytes. (bitsLen:${e.bitsLen}, bytesLen:${e.bytes.length})`);const t=g.enc(e.bitsLen),n=new Uint8Array(e.bytes.length+t.length);return n.set(t,0),n.set(e.bytes,t.length),n},Wn=J(Hn,Rn),Fn=ce(U,e=>e.charCodeAt(0),String.fromCharCode),Xt=e=>{const t=j.enc(e);return n=>t(Re(n))},Jt=e=>{const t=j.dec(e);return n=>ne(t(n))},R=e=>J(Xt(e),Jt(e));R.enc=Xt;R.dec=Jt;const Qt=new TextEncoder,qn=new TextDecoder,jn=e=>ce(j(e),t=>Qt.encode(t),t=>qn.decode(t)),Zt=e=>{let t=n=>{const s=e();return t=s,s(n)};return n=>t(n)},en=e=>{let t=n=>{const s=e(),r=s;return t=s,r(n)};return n=>t(n)},tn=e=>J(Zt(()=>e().enc),en(()=>e().dec)),zn={is(e,t){return e.type===t},as(e,t){if(t!==e.type)throw new Error(`Enum.as(enum, ${t}) used with actual type ${e.type}`);return e}},it=Object.assign((e,t)=>({type:e,value:t}),zn),Kn=new Proxy({},{get(e,t){return n=>it(t,n)}}),A=(e,t)=>{const n=e;return n.inner=t,n},nn=(...e)=>{const t=K.enc(...e);return A(n=>t({tag:n.type,value:n.value}),e[0])},sn=(...e)=>{const t=K.dec(...e);return A(n=>{const{tag:s,value:r}=t(n);return it(s,r)},e[0])},ke=(e,...t)=>A(J(nn(Ze(e,([n])=>n),...t),sn(Ze(e,([,n])=>n),...t)),e);ke.enc=nn;ke.dec=sn;const ge=(e,...t)=>A(K(e,...t),e);ge.enc=(e,...t)=>A(K.enc(e,...t),e);ge.dec=(e,...t)=>A(K.dec(e,...t),e);const rn=Pn,bt=e=>{const t=e.slice(2),n=ne(rn(Qt.encode(t))).slice(2),s=new Array(40);for(let r=0;r<40;r++){const o=parseInt(n[r],16),c=t[r];s[r]=o>7?c.toUpperCase():c}return`0x${s.join("")}`},Gn=j(20)[1],lt=J(e=>{const t=Re(e);if(t.length!==20)throw new Error(`Invalid length found on EthAddress(${e})`);const n=ne(t);if(e===n||e===n.toUpperCase())return t;if(bt(n)!==e)throw new Error(`Invalid checksum found on EthAddress(${e})`);return t},pe(e=>bt(ne(Gn(e))))),$=e=>A(w(e),e);$.enc=e=>A(w.enc(e),e);$.dec=e=>A(w.dec(e),e);const te=(...e)=>A(fe(...e),e);te.enc=(...e)=>A(fe.enc(...e),e);te.dec=(...e)=>A(fe.dec(...e),e);const N=(e,...t)=>A(b(e,...t),e);N.enc=(e,...t)=>A(b.enc(e,...t),e);N.dec=(e,...t)=>A(b.dec(e,...t),e);const He=(e,t)=>A(rt(e,t),{ok:e,ko:t});He.enc=(e,t)=>A(rt.enc(e,t),{ok:e,ko:t});He.dec=(e,t)=>A(rt.dec(e,t),{ok:e,ko:t});const Te=e=>A(G(e),e);Te.enc=e=>A(G.enc(e),e);Te.dec=e=>A(G.dec(e),e);const on=(e=!0)=>pe(t=>{const n=g.dec(t),s=Math.ceil(n/8),r=j(s).dec(t),o=new Array(n);let c=0;return r.forEach(a=>{for(let d=0;d<8&&c<n;d++){const i=e?d:7-d;o[c++]=a>>i&1}}),o}),cn=(e=!0)=>t=>{const n=g.enc(t.length),s=Math.ceil(t.length/8),r=new Uint8Array(s);for(let o=0;o<s;o++){let c=o*8,a=0;for(let d=0;d<8&&c<t.length;d++,c++)a|=t[c]<<(e?d:7-d);r[o]=a}return B([n,r])},We=e=>J(cn(e),on(e));We.enc=cn;We.dec=on;const It=new TextEncoder,St=new TextDecoder,Yn=ce(j(4),It.encode.bind(It),St.decode.bind(St)),ze=$({engine:Yn,payload:R()}),Xn=ke({other:j(),consensus:ze,seal:ze,preRuntime:ze,runtimeUpdated:p},[0,4,5,6,8]),Ke=R(32),Jn=$({parentHash:Ke,number:g,stateRoot:Ke,extrinsicRoot:Ke,digests:N(Xn)}),q=b(E),kt=G(E),Qn=K({bool:p,char:p,str:p,u8:p,u16:p,u32:p,u64:p,u128:p,u256:p,i8:p,i16:p,i32:p,i64:p,i128:p,i256:p}),an=b(w({name:kt,type:g,typeName:kt,docs:q})),Zn=w({len:X,type:g}),es=w({bitStoreType:g,bitOrderType:g}),ts=b(w({name:E,fields:an,index:U,docs:q})),ns=K({composite:an,variant:ts,sequence:g,array:Zn,tuple:b(g),primitive:Qn,compact:g,bitSequence:es}),ss=w({name:E,type:G(g)}),rs=b(ss),os=w({id:g,path:q,params:rs,def:ns,docs:q}),Fe=b(os),Ee=K({NotDeprecated:p,DeprecatedWithoutNote:p,Deprecated:w({note:E,since:G(E)})}),cs=b(w({index:U,deprecation:K({DeprecatedWithoutNote:p,Deprecated:w({note:E,since:G(E)})},[1,2])})),ut={name:E,inputs:b(w({name:E,type:g})),output:g,docs:q},as=w({name:E,methods:b(w(ut)),docs:q}),is=w({name:E,methods:b(w({...ut,deprecationInfo:Ee})),docs:q,version:g,deprecationInfo:Ee}),ls=w({id:R(32),...ut,deprecationInfo:Ee}),us=K({Blake2128:p,Blake2256:p,Blake2128Concat:p,Twox128:p,Twox256:p,Twox64Concat:p,Identity:p}),ds=b(us),hs=w({hashers:ds,key:g,value:g}),ln={name:E,modifier:U,type:K({plain:g,map:hs}),fallback:R(),docs:q},Ge=G(g),un={name:E,storage:G(w({prefix:E,items:b(w(ln))})),calls:Ge,events:Ge,constants:b(w({name:E,type:g,value:R(),docs:q})),errors:Ge,index:U},ps={...un,docs:q},Ye=G(w({type:g,deprecationInfo:cs})),fs={name:E,storage:G(w({prefix:E,items:b(w({...ln,deprecationInfo:Ee}))})),calls:Ye,events:Ye,constants:b(w({name:E,type:g,value:R(),docs:q,deprecationInfo:Ee})),errors:Ye,associatedTypes:b(w({name:E,type:g,docs:q})),viewFns:b(ls),index:U,docs:q,deprecationInfo:Ee},ys=new Uint8Array,Tt=e=>J(()=>ys,()=>e),gs=w({type:g,version:U,signedExtensions:b(w({identifier:E,type:g,additionalSigned:g}))}),dn=w({lookup:Fe,pallets:b(w({...un,docs:Tt([])})),extrinsic:gs,type:g,apis:Tt([])}),vs=w({version:U,address:g,call:g,signature:g,extra:g,signedExtensions:b(w({identifier:E,type:g,additionalSigned:g}))}),hn=w({lookup:Fe,pallets:b(w(ps)),extrinsic:vs,type:g,apis:b(as),outerEnums:w({call:g,event:g,error:g}),custom:b(fe(E,w({type:g,value:R()})))}),ms=w({version:b(U),address:g,call:g,signature:g,signedExtensionsByVersion:b(fe(U,b(g))),signedExtensions:b(w({identifier:E,type:g,additionalSigned:g}))}),pn=w({lookup:Fe,pallets:b(w(fs)),extrinsic:ms,apis:b(is),outerEnums:w({call:g,event:g,error:g}),custom:b(fe(E,w({type:g,value:R()})))}),At=()=>{throw new Error("Unsupported metadata version!")},H=J(At,At),Pe=w({magicNumber:X,metadata:K({v0:H,v1:H,v2:H,v3:H,v4:H,v5:H,v6:H,v7:H,v8:H,v9:H,v10:H,v11:H,v12:H,v13:H,v14:dn,v15:hn,v16:pn})}),dt=j(),ws=G(dt),xs=fe(C,dt),ht=e=>{try{return Pe.dec(e)}catch{}try{return Pe.dec(ws.dec(e))}catch{}try{return Pe.dec(dt.dec(e))}catch{}try{return Pe.dec(xs.dec(e)[1])}catch{}throw null},pt=e=>{if("magicNumber"in e&&(e=e.metadata),"tag"in e){if(e.tag!=="v14"&&e.tag!=="v15"&&e.tag!=="v16")throw new Error("Only metadata 14, 15, and 16 are supported");e=e.value}if("signedExtensionsByVersion"in e.extrinsic)return{version:16,...e};if("custom"in e){const{lookup:r,extrinsic:o,custom:c,apis:a,pallets:d,outerEnums:i}=e;return{version:15,lookup:r,pallets:d.map(h=>({...h,calls:h.calls!=null?{type:h.calls}:void 0,events:h.events!=null?{type:h.events}:void 0,errors:h.errors!=null?{type:h.errors}:void 0,viewFns:[],associatedTypes:[]})),extrinsic:{...o,version:[o.version]},apis:a,outerEnums:i,custom:c}}const{lookup:t,extrinsic:n,pallets:s}=e;return{version:14,lookup:t,pallets:s.map(r=>({...r,calls:r.calls!=null?{type:r.calls}:void 0,events:r.events!=null?{type:r.events}:void 0,errors:r.errors!=null?{type:r.errors}:void 0,viewFns:[],associatedTypes:[]})),extrinsic:{...n,version:[n.version]},apis:[]}},ue={bare:0,0:"bare",general:1,1:"general",signed:2,2:"signed"},ft=ce(U,({version:e,type:t})=>e+(ue[t]<<6),e=>{const t=e&63,n=e>>6;if(t===4&&(n===ue.bare||n===ue.signed))return{version:t,type:ue[n]};if(t===5&&(n===ue.bare||n===ue.general))return{version:t,type:ue[n]};throw new Error(`ExtrinsicFormat ${e} not valid`)}),Es={dkLen:32},qe=e=>Vt(e,Es),bs={dkLen:16},yt=e=>Vt(e,bs),fn=e=>B([yt(e),e]),Is={dkLen:32},xe=e=>Ln(e,Is),Ss=e=>B([xe(e),e]),yn=e=>e,de=(e,t,n,s)=>new DataView(new Uint16Array([e,t,n,s]).buffer).getBigUint64(0,!0),gt=2n**64n-1n,V=(e,t)=>e<<t&gt|e>>64n-t,k=(e,t)=>e*t&gt,D=(e,t)=>e+t&gt,P=11400714785074694791n,W=14029467366897019727n,Bt=1609587929392839161n,Ue=9650029242287828579n,Ut=2870177450012600261n;function oe(e,t=0n){let n=D(D(t,P),W),s=D(t,W),r=t,o=t-P,c=e.length,a=0,d=null;(function(){let u=0,y=u+c;if(c){if(d=new Uint8Array(32),c<32){d.set(e.subarray(0,c),a),a+=c;return}if(u<=y-32){const f=y-32;do{let v;v=de(e[u+1]<<8|e[u],e[u+3]<<8|e[u+2],e[u+5]<<8|e[u+4],e[u+7]<<8|e[u+6]),n=k(V(D(n,k(v,W)),31n),P),u+=8,v=de(e[u+1]<<8|e[u],e[u+3]<<8|e[u+2],e[u+5]<<8|e[u+4],e[u+7]<<8|e[u+6]),s=k(V(D(s,k(v,W)),31n),P),u+=8,v=de(e[u+1]<<8|e[u],e[u+3]<<8|e[u+2],e[u+5]<<8|e[u+4],e[u+7]<<8|e[u+6]),r=k(V(D(r,k(v,W)),31n),P),u+=8,v=de(e[u+1]<<8|e[u],e[u+3]<<8|e[u+2],e[u+5]<<8|e[u+4],e[u+7]<<8|e[u+6]),o=k(V(D(o,k(v,W)),31n),P),u+=8}while(u<=f)}u<y&&(d.set(e.subarray(u,y),a),a=y-u)}})(),e=d||e;let i,h=0;for(c>=32?(i=V(n,1n),i=D(i,V(s,7n)),i=D(i,V(r,12n)),i=D(i,V(o,18n)),n=k(V(k(n,W),31n),P),i=i^n,i=D(k(i,P),Ue),s=k(V(k(s,W),31n),P),i=i^s,i=D(k(i,P),Ue),r=k(V(k(r,W),31n),P),i=i^r,i=D(k(i,P),Ue),o=k(V(k(o,W),31n),P),i=i^o,i=D(k(i,P),Ue)):i=D(t,Ut),i=D(i,BigInt(c));h<=a-8;){let l=de(e[h+1]<<8|e[h],e[h+3]<<8|e[h+2],e[h+5]<<8|e[h+4],e[h+7]<<8|e[h+6]);l=k(V(k(l,W),31n),P),i=D(k(V(i^l,27n),P),Ue),h+=8}if(h+4<=a){let l=k(de(e[h+1]<<8|e[h],e[h+3]<<8|e[h+2],0,0),P);i=D(k(V(i^l,23n),W),Bt),h+=4}for(;h<a;){const l=k(de(e[h++],0,0,0),Ut);i=k(V(i^l,11n),P)}let m=i>>33n;return i=k(i^m,W),m=i>>29n,i=k(i^m,Bt),m=i>>32n,i^=m,i}const Ne=e=>{const t=new Uint8Array(16),n=new DataView(t.buffer);return n.setBigUint64(0,oe(e),!0),n.setBigUint64(8,oe(e,1n),!0),t},gn=e=>{const t=new Uint8Array(32),n=new DataView(t.buffer);return n.setBigUint64(0,oe(e),!0),n.setBigUint64(8,oe(e,1n),!0),n.setBigUint64(16,oe(e,2n),!0),n.setBigUint64(24,oe(e,3n),!0),t},vn=e=>B([ot.enc(oe(e)),e]),_t=new TextEncoder,ks=new Map([[yn,0],[vn,8],[fn,16],[yt,-16],[qe,-32],[Ne,-16],[gn,-32]]),mn=e=>{const t=Ne(_t.encode(e));return(n,...s)=>{const r=B([t,Ne(_t.encode(n))]),o=ne(r),c=i=>{if(!i.startsWith(o))throw new Error(`key does not match this storage (${e}.${n})`);if(s.length===0)return[];const h=Re(i.slice(o.length)),m=new Array(s.length);for(let l=0,u=0;l<s.length;l++){const[y,f]=s[l],v=ks.get(f);if(v==null)throw new Error("Unknown hasher");if(v<0){const I=v*-1;m[l]=ne(h.slice(u,u+I)),u+=I}else u+=v,m[l]=y.dec(h.slice(u)),u+=y.enc(m[l]).length}return m},a=s.map(([{enc:i},h])=>m=>h(i(m)));return{enc:(...i)=>ne(B([r,...i.map((h,m)=>a[m](h))])),dec:c}}},Ts=Me.fromText("modlpy/utilisuba").asBytes(),As=({threshold:e,signatories:t})=>{const n=wn(t),s=B([Ts,C.enc(n.length),...n,ye.enc(e)]);return qe(s)},wn=e=>e.slice().sort((t,n)=>{for(let s=0;;s++){const r=s>=t.length,o=s>=n.length;if(r&&o)return 0;if(r)return-1;if(o)return 1;if(t[s]!==n[s])return t[s]>n[s]?1:-1}}),re={Leaf:"Leaf",Branch:"Branch",BranchWithVal:"BranchWithVal",LeafWithHash:"LeafWithHash",BranchWithHash:"BranchWithHash",Empty:"Empty",Reserved:"Reserved"},Dt=R().dec,Bs=R(1/0).dec,Us=R(32).dec,Pt=U.dec,_s=e=>{const t=Pt(e);let n=6;const s=t>>n,r=s?s===1?re.Leaf:s===2?re.Branch:re.BranchWithVal:t>>--n?re.LeafWithHash:t>>--n?re.BranchWithHash:t?re.Reserved:re.Empty;let o=t&255>>8-n;if(o===2**n-1){let c;do o+=c=Pt(e);while(c===255)}return{type:r,partialKey:R(Math.ceil(o/2)).dec(e).slice(o%2?3:2)}},xn=pe(e=>{const t=_s(e),{type:n}=t;if(n==="Empty"||n==="Reserved")return t;if(n==="Leaf"||n==="LeafWithHash")return{...t,value:Bs(e)};const s=ye.dec(e),r=[];for(let a=0;a<16;a++)s>>a&1&&r.push(a.toString(16));let o=null;n==="BranchWithVal"&&(o=Dt(e)),n==="BranchWithHash"&&(o=Us(e));const c={...t,children:Object.fromEntries(r.map(a=>[a,Dt(e)]))};return o!==null&&(c.value=o),c}),En=e=>pe(t=>{const n=ne(e(new Uint8Array(t.buffer)));try{return{hash:n,...xn(t)}}catch{return{type:"Raw",hash:n,value:""}}}),Ds=(e,t=qe)=>{const n=e.map(En(t)),s=Object.fromEntries(n.map(a=>[a.hash,a])),r=n.map(a=>a.hash),o=new Set(r),c=a=>{if(a.value)return;const d=e[r.indexOf(a.hash)];a.value=typeof d=="string"?d:ne(d)};return n.forEach(a=>{if("children"in a&&Object.values(a.children).forEach(d=>{const i=s[d];i&&(i.parent=a.hash,o.delete(d))}),a.type==="BranchWithHash"||a.type==="LeafWithHash"){const d=a.value,i=s[d];if(!i)return;o.delete(d),i.type!=="Raw"&&(Object.keys(i).forEach(h=>delete i[h]),i.type="Raw",i.hash=d),i.parent=a.hash,c(i)}a.type==="Raw"&&c(a)}),o.size===1?{rootHash:o.values().next().value,proofs:s}:null},bn=Object.freeze(Object.defineProperty({__proto__:null,AccountId:ct,Bin:at,Binary:Me,BitSeq:We,Blake2128:yt,Blake2128Concat:fn,Blake2256:qe,Blake3256:xe,Blake3256Concat:Ss,Bytes:j,Enum:it,FixedSizeBinary:Mn,Hex:R,Identity:yn,Keccak256:rn,Option:Te,Result:He,ScaleEnum:ge,Self:tn,Storage:mn,Struct:$,TrieNodeHeaders:re,TrieNodeWithHash:En,Tuple:te,Twox128:Ne,Twox256:gn,Twox64Concat:vn,Variant:ke,Vector:N,_Enum:Kn,_void:p,bitSequence:Wn,blockHeader:Jn,bool:Nt,char:Fn,compact:C,compactBn:Yt,compactNumber:g,createCodec:J,createDecoder:pe,decAnyMetadata:ht,enhanceCodec:ce,enhanceDecoder:Cn,enhanceEncoder:$n,ethAccount:lt,extrinsicFormat:ft,fixedStr:jn,fromBufferToBase58:On,getMultisigAccountId:As,getSs58AddressInfo:Vn,h64:oe,i128:Rt,i16:Ht,i256:Wt,i32:Ft,i64:qt,i8:jt,metadata:Pe,selfDecoder:en,selfEncoder:Zt,sortMultisigSignatories:wn,str:E,trieNodeDec:xn,u128:zt,u16:ye,u256:Kt,u32:X,u64:ot,u8:U,unifyMetadata:pt,v14:dn,v14Lookup:Fe,v15:hn,v16:pn,validateProofs:Ds},Symbol.toStringTag,{value:"Module"})),Ps=(e,t,n)=>(s,r,o,...c)=>{const{id:a}=s;if(r.has(a))return r.get(a);if(o.has(a)){const i=t(()=>r.get(a),s,...c);return r.set(a,i),i}o.add(a);let d=e(s,r,o,...c);return o.delete(a),r.has(a)&&(d=n(d,r.get(a),s,...c)),r.set(a,d),d},Ls=at(),Ms=(e,t,n,s)=>{if(e.type==="primitive")return bn[e.value];if(e.type==="void")return p;if(e.type==="AccountId32")return s;if(e.type==="AccountId20")return lt;if(e.type==="compact")return e.isBig?Yt:g;if(e.type==="bitSequence")return We(e.isLSB);const r=u=>In(u,t,n,s),o=(u,y)=>{const f=r(u);return y?N(f,y):N(f)},c=u=>te(...u.map(r)),a=u=>{const y=Object.fromEntries(Object.entries(u).map(([f,v])=>[f,r(v)]));return $(y)};if(e.type==="sequence"&&e.value.type==="primitive"&&e.value.value==="u8")return Ls;if(e.type==="array")return e.value.type==="primitive"&&e.value.value==="u8"?at(e.len):o(e.value,e.len);if(e.type==="sequence")return o(e.value);if(e.type==="tuple")return c(e.value);if(e.type==="struct")return a(e.value);if(e.type==="option")return Te(r(e.value));if(e.type==="result")return He(r(e.value.ok),r(e.value.ko));const d=Object.values(e.value).map(u=>{switch(u.type){case"void":return p;case"lookupEntry":return r(u.value);case"tuple":return c(u.value);case"struct":return a(u.value);case"array":return o(u.value,u.len)}}),i=Object.fromEntries(Object.keys(e.value).map((u,y)=>[u,d[y]])),h=Object.values(e.value).map(u=>u.idx),l=h.every((u,y)=>u===y)?ke(i):ke(i,h);return e.byteLength?Cs(l,e.byteLength):l},In=Ps(Ms,tn,e=>e),Lt=(e,t=ct())=>{const n=new Map,s=r=>In(e(r),n,new Set,t);return r=>s(r)},Cs=(e,t)=>{const n=j(t);return J(s=>n.enc(e.enc(s)),s=>e.dec(n.dec(s)))},$s=ce(p,()=>{},()=>null),Os=e=>{const{metadata:t}=e;let n=Lt(e);const s=t.pallets.find(l=>l.name==="System")?.constants.find(l=>l.name==="SS58Prefix");let r;if(s)try{const l=n(s.type).dec(s.value);typeof l=="number"&&(r=l,n=Lt(e,ct(l)))}catch{}const o=new Map,c=(l,u)=>{let y=o.get(l);y||o.set(l,y=mn(l));const f=t.pallets.find(L=>L.name===l).storage.items.find(L=>L.name===u),v=L=>L===p?$s:L,I=(L,ie,...Be)=>{const S=y(...Be),[,...x]=Be;return{args:te(...x.map(([_])=>_)),keys:S,value:ie,len:L,fallback:f.modifier===1?ie.dec(f.fallback):void 0}};if(f.type.tag==="plain")return I(0,v(n(f.type.value)),u);const{key:O,value:z,hashers:Ce}=f.type.value,Ae=v(n(z)),ae=Ce.map(L=>bn[L.tag]),$e=(()=>{if(ae.length===1)return[[n(O),ae[0]]];const L=e(O);switch(L.type){case"array":return ae.map(ie=>[n(L.value.id),ie]);case"tuple":return L.value.map((ie,Be)=>[n(ie.id),ae[Be]]);default:throw new Error("Invalid key type")}})();return I(ae.length,Ae,u,...$e)},a=l=>{switch(l.type){case"void":return p;case"lookupEntry":return n(l.value.id);case"tuple":return te(...Object.values(l.value).map(u=>n(u.id)));case"struct":return $(Ze(l.value,u=>n(u.id)));case"array":return N(n(l.value.id),l.len)}},d=(l,u)=>{const y=t.pallets.find(f=>f.name===l).constants.find(f=>f.name===u);return n(y.type)},i=l=>(u,y)=>{const f=t.pallets.find(O=>O.name===u),v=e(f[l].type);if(v.type!=="enum")throw null;const I=v.value[y];return{location:[f.index,I.idx],codec:a(v.value[y])}},h=(l,u)=>{const y=t.pallets.find(f=>f.name===l)?.viewFns.find(f=>f.name===u);if(!y)throw null;return{args:te(...y.inputs.map(f=>n(f.type))),value:n(y.output)}},m=(l,u)=>{const y=t.apis.find(f=>f.name===l)?.methods.find(f=>f.name===u);if(!y)throw null;return{args:te(...y.inputs.map(f=>n(f.type))),value:n(y.output)}};return{buildDefinition:n,buildStorage:c,buildEvent:i("events"),buildError:i("errors"),buildViewFn:h,buildRuntimeCall:m,buildCall:i("calls"),buildConstant:d,ss58Prefix:r}},Sn={specVersion:X,specName:E,base58Prefix:ye,decimals:U,tokenSymbol:E},kn=$(Sn),et=j(32),Vs=ge({V0:p,V1:$({typeInformationTreeRoot:et,extrinsicMetadataHash:et,...Sn})});ge({bool:p,char:p,str:p,u8:p,u16:p,u32:p,u64:p,u128:p,u256:p,i8:p,i16:p,i32:p,i64:p,i128:p,i256:p});const ee=ge({bool:p,char:p,str:p,u8:p,u16:p,u32:p,u64:p,u128:p,u256:p,i8:p,i16:p,i32:p,i64:p,i128:p,i256:p,compactU8:p,compactU16:p,compactU32:p,compactU64:p,compactU128:p,compactU256:p,void:p,perId:g}),Mt=$({name:Te(E),ty:ee,typeName:Te(E)}),Ns=ge({composite:N(Mt),enumeration:$({name:E,fields:N(Mt),index:g}),sequence:ee,array:$({len:X,typeParam:ee}),tuple:N(ee),bitSequence:$({numBytes:U,leastSignificantBitFirst:Nt})}),Tn=$({path:N(E),typeDef:Ns,typeId:g}),Rs=N(Tn),tt=$({version:U,addressTy:ee,callTy:ee,signatureTy:ee,signedExtensions:N($({identifier:E,includedInExtrinsic:ee,includedInSignedData:ee}))}),Hs=te.dec(C[1],ft[1],j(1/0)[1]);$({leaves:Rs,leafIdxs:N(X),proofs:N(et),extrinsic:tt,info:kn});const Ws=(e,t)=>{const n=new Set,s=o=>{if(n.has(o))return;const{tag:c,value:a}=t.get(o).def;switch(c){case"composite":if(!a.length)break;n.add(o),a.forEach(({type:d})=>{s(d)});break;case"variant":if(!a.length)break;n.add(o),a.forEach(({fields:d})=>{d.forEach(({type:i})=>{s(i)})});break;case"tuple":if(!a.length)break;n.add(o),a.forEach(s);break;case"sequence":n.add(o),s(a);break;case"array":n.add(o),s(a.type);break;case"bitSequence":n.add(o)}};s(e.extrinsic.call),s(e.extrinsic.address),s(e.extrinsic.signature),e.extrinsic.signedExtensions.forEach(({type:o,additionalSigned:c})=>{s(o),s(c)});const r=[...n].sort((o,c)=>o-c);return new Map(r.map((o,c)=>[o,c]))},Fs={u8:1,u16:2,u32:4,u64:8},qs=(e,t,n,s)=>{const{def:{tag:r,value:o}}=e.get(s);switch(r){case"composite":return[{tag:r,value:o.map(c=>({name:c.name,typeName:c.typeName,ty:t(c.type)}))}];case"variant":return o.map(c=>({tag:"enumeration",value:{name:c.name,index:c.index,fields:c.fields.map(a=>({name:a.name,typeName:a.typeName,ty:t(a.type)}))}}));case"sequence":return[{tag:r,value:t(o)}];case"array":return[{tag:r,value:{len:o.len,typeParam:t(o.type)}}];case"tuple":return[{tag:r,value:o.map(t)}];case"bitSequence":{const c=n(o.bitStoreType),a=Fs[c];if(!a)throw new Error("Invalid primitive for BitSequence");const d=e.get(o.bitOrderType).path,i=d.includes("Lsb0");if(!i&&!d.includes("Msb0"))throw new Error("BitOrderType not recognized");return[{tag:"bitSequence",value:{numBytes:a,leastSignificantBitFirst:i}}]}}throw new Error(`FrameId(${s}) should have been filtered out`)},js=(e,t,n,s)=>{const r=[];return[...t.entries()].forEach(([o,c])=>{const{path:a}=e.get(o);qs(e,n,s,o).forEach(d=>{r.push({path:a,typeId:c,typeDef:d})})}),r.sort((o,c)=>{if(o.typeId!==c.typeId)return o.typeId-c.typeId;if(o.typeDef.tag!=="enumeration"||c.typeDef.tag!=="enumeration")throw new Error("Found two types with same id");return o.typeDef.value.index-c.typeDef.value.index}),r},zs=e=>{try{const t=pt(ht(e));if(t.version<=14)throw new Error("Wrong metadata version");return t}catch(t){throw t||new Error("Unable to decode metadata")}},Ct=e=>typeof e=="string"?Re(e):e,Ks={null:"void",u8:"compactU8",u16:"compactU16",u32:"compactU32",u64:"compactU64",u128:"compactU128",u256:"compactU256"},Gs={bool:U,char:U,str:E,u8:U,u16:ye,u32:X,u64:ot,u128:zt,u256:Kt,i8:jt,i16:Ht,i32:Ft,i64:qt,i128:Rt,i256:Wt,void:p,compactU8:C,compactU16:C,compactU32:C,compactU64:C,compactU128:C,compactU256:C},An=(e,t,n,s,r)=>{if(t.tag!=="perId"){Gs[t.tag][1](e);return}const o=i=>{An(e,i,n,s,r)},c=n.get(t.value),[a]=c,d=s[a];switch(c.length===1&&r.add(a),d.typeDef.tag){case"enumeration":{const i=U.dec(e),[h,m]=c.map(l=>[s[l].typeDef,l]).find(([l])=>l.value.index===i);r.add(m),h.value.fields.forEach(({ty:l})=>{o(l)});break}case"sequence":{const i=C.dec(e);for(let h=0;h<i;h++)o(d.typeDef.value);break}case"array":{for(let i=0;i<d.typeDef.value.len;i++)o(d.typeDef.value.typeParam);break}case"composite":{d.typeDef.value.forEach(i=>{o(i.ty)});break}case"tuple":{d.typeDef.value.forEach(o);break}case"bitSequence":throw new Error("bitSequence is not supported")}},$t=(e,t,n)=>{let s=new Uint8Array;pe(c=>{s=c})(e);const r=new Map;n.forEach((c,a)=>{const d=r.get(c.typeId);d?d.push(a):r.set(c.typeId,[a])});const o=new Set;return t.forEach(c=>{An(s,c,r,n,o)}),[...o].sort((c,a)=>c-a)},Xe=e=>Math.log2(e+1)|0,Ys=(e,t)=>(e+1>>t)-1;function Xs(e,t){const n=t.map(d=>e[d]),s=e.length-1,r=t.map(d=>s+d),o=[];if(r.length){const d=Xe(r.at(-1)),i=Math.pow(2,d)-1,h=r.findIndex(m=>m>=i);h>0&&(r.unshift(...r.splice(h)),n.unshift(...n.splice(h)))}let c=0;const a=d=>{if(c===r.length){o.push(d);return}const i=r[c];if(i===d){++c;return}const h=Xe(d),m=Xe(i);if(d!==Ys(i,m-h)){o.push(d);return}const l=2*d+1;a(l),a(l+1)};return a(0),{leaves:n,leafIdxs:r,proofIdxs:o}}const Je=(e,t,n)=>{if(n!=null&&n!==t)throw new Error(`${e} not expected. Received ${n} expected ${t}`)},Js=(e,{decimals:t,tokenSymbol:n,...s})=>{const r=zs(e),o=r.extrinsic.version.includes(4)?4:null;if(o==null)throw new Error("Only extrinsic v4 is supported");const{ss58Prefix:c,buildDefinition:a}=Os(Gt(r));if(c==null)throw new Error("SS58 prefix not found in metadata");Je("SS58 prefix",c,s.base58Prefix);const d=r.pallets.find(S=>S.name==="System")?.constants.find(S=>S.name==="Version");if(d==null)throw new Error("System.Version constant not found");const{spec_name:i,spec_version:h}=a(d.type).dec(d.value);if(typeof i!="string"||typeof h!="number")throw new Error("Spec name or spec version not found");Je("Spec name",i,s.specName),Je("Spec version",h,s.specVersion);const m={decimals:t,tokenSymbol:n,specVersion:h,specName:i,base58Prefix:c},l=new Map(r.lookup.map(S=>[S.id,S])),u=Ws(r,l),y=S=>{const{def:{tag:x,value:_}}=l.get(S);if(x==="primitive")return _.tag;if(x!=="composite"&&x!=="tuple"||_.length>1)throw new Error("The provided definition doesn't map to a primitive");return _.length===0?null:y(x==="tuple"?_[0]:_[0].type)},f=S=>{const{def:x}=l.get(S);if(x.tag==="primitive")return{tag:x.value.tag,value:void 0};if(x.tag==="compact"){const _=y(x.value),Q=Ks[_];if(!Q)throw new Error("Invalid primitive for Compact");return{tag:Q,value:void 0}}return u.has(S)?{tag:"perId",value:u.get(S)}:{tag:"void",value:void 0}},v={version:o,addressTy:f(r.extrinsic.address),callTy:f(r.extrinsic.call),signatureTy:f(r.extrinsic.signature),signedExtensions:r.extrinsic.signedExtensions.map(S=>({identifier:S.identifier,includedInExtrinsic:f(S.type),includedInSignedData:f(S.additionalSigned)}))},I=js(l,u,f,y),O=I.map(Tn.enc);let z;const Ce=()=>{if(z)return z;if(!O.length)return z=[new Uint8Array(32).fill(0)];z=new Array(O.length*2-1);let S=O.length-1;for(let x=0;x<O.length;x++)z[S+x]=xe(O[x]);for(let x=z.length-2;x>0;x-=2)z[(x-1)/2]=xe(B([z[x],z[x+1]]));return z};let Ae;const ae=()=>{if(Ae)return Ae;const x={tag:"V1",value:{typeInformationTreeRoot:Ce()[0],extrinsicMetadataHash:xe(tt.enc(v)),...m}};return Ae=xe(Vs.enc(x))},$e=S=>{const x=Xs(O,S),_=Ce(),Q=x.proofIdxs.map(le=>_[le]);return B([C.enc(x.leaves.length),...x.leaves,C.enc(x.leafIdxs.length),...x.leafIdxs.map(le=>X.enc(le)),C.enc(Q.length),...Q,tt.enc(v),kn.enc(m)])},L=S=>{const x=[v.callTy,...v.signedExtensions.map(_=>_.includedInExtrinsic),...v.signedExtensions.map(_=>_.includedInSignedData)];return $e($t(S,x,I))};return{digest:ae,getProofForExtrinsic:(S,x)=>{let[,{version:_,type:Q},le]=Hs(S);if(_!==v.version)throw new Error("Incorrect extrinsic version");const xt=Q==="signed"?[v.addressTy,v.signatureTy,...v.signedExtensions.map(je=>je.includedInExtrinsic),v.callTy]:[v.callTy];return x&&(le=B([le,Ct(x)]),xt.push(...v.signedExtensions.map(je=>je.includedInSignedData))),$e($t(le,xt,I))},getProofForExtrinsicParts:(S,x,_)=>{const Q=B([S,x,_].map(Ct));return L(Q)},getProofForExtrinsicPayload:L}},Qs=e=>{try{const t=pt(ht(e));if(t.version<=14)throw new Error("Wrong metadata version");return t}catch(t){throw t||new Error("Unable to decode metadata")}},Bn=249,nt={getAddress:1,signTx:2,signRaw:3},Le={init:0,continue:1,end:2,getAddress:0,showAddress:1},Un={ed25519:0,ecdsa:2},_e={ed25519:32,ecdsa:33},Zs={ed25519:64,ecdsa:65},er=0,Qe=()=>new Error("Unkown signer"),tr=e=>{const{extrinsic:t}=e,n=Gt(e);let s,r;if("address"in t)s=n(t.address),r=n(t.signature);else{const o=Object.fromEntries(e.lookup[t.type].params.filter(c=>c.type!=null).map(c=>[c.name,n(c.type)]));if(s=o.Address,r=o.Signature,!s||!r)throw Qe()}if(s.type==="AccountId20"&&r.type==="array"&&r.len===65&&r.value.type==="primitive"&&r.value.value==="u8")return[1,[]];if(r.type!=="enum"||["Ecdsa","Ed25519","Sr25519"].some(o=>!(o in r.value)))throw Qe();if(s.type==="enum"){const o=s.value.Id;if(o.type==="lookupEntry"&&o.value.type==="AccountId32")return[0,[o.idx]]}else if(s.type==="AccountId32")return[0,[]];throw Qe()},nr=(e,t,n,s,r,o)=>{const[c,a]=tr(e),d=B([ft.enc({version:4,type:"signed"}),c===1?t:new Uint8Array([...a,...t]),n,...s,r]);return B([C.enc(d.length),d])},[Oe,De]=["<Bytes>","</Bytes>"].map(e=>Me.fromText(e).asBytes()),sr=e=>async t=>{let n=!0,s;for(s=0;n&&s<Oe.length;s++)n=Oe[s]===t[s];n=n&&s===Oe.length;const r=t.length-De.length;for(s=0;n&&s<De.length;s++)n=De[s]===t[r+s];return n=n&&s===De.length,e(n?t:B([Oe,t,De]))};var _n=e=>{throw TypeError(e)},vt=(e,t,n)=>t.has(e)||_n("Cannot "+n),T=(e,t,n)=>(vt(e,t,"read from private field"),n?n.call(e):t.get(e)),he=(e,t,n)=>t.has(e)?_n("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,n),Z=(e,t,n,s)=>(vt(e,t,"write to private field"),t.set(e,n),n),Y=(e,t,n)=>(vt(e,t,"access private method"),n),be,M,Ie,ve,me,Se,F,mt,wt,we,st;const Ot="CheckMetadataHash",rr=Uint8Array.from([44,0,0,128,98,1,0,128]),or=Uint8Array.from([0,0,0,128]),Ve=2147483648,Dn=(e,t)=>{if(!Number.isInteger(e)||e<0||e>=Ve||!Number.isInteger(t)||t<0||t>=Ve)throw new Error(`Invalid path segments ${e}, ${t}`);return B([rr,X.enc(Ve+e),or,X.enc(Ve+t)])};class ar{constructor(t,n="ed25519"){he(this,F),he(this,be),he(this,M),he(this,Ie),he(this,ve),he(this,me),he(this,Se),Z(this,ve,null),Z(this,me,null),Z(this,Se,null),Z(this,be,t),Z(this,M,n),Z(this,Ie,new Map)}async appInfo(){return T(this,me)||Z(this,me,Y(this,F,mt).call(this,176,1,0,0).then(t=>{const n=Uint8Array.from(t),s=Me.fromBytes(n.slice(2,2+n[1])).asText(),r=Me.fromBytes(n.slice(2+n[1]+1,2+n[1]+1+n[2+n[1]])).asText();return{appName:s,appVersion:r}})),T(this,me)}async deviceId(){return T(this,ve)||Z(this,ve,Y(this,F,we).call(this,0,0).then(t=>X.dec(t.slice(0,4)))),T(this,ve)}async getPubkey(t,n=0){return await Y(this,F,we).call(this,t,n).then(s=>s.slice(0,_e[T(this,M)]))}async seeAddressInDevice(t,n,s=0){return await Y(this,F,we).call(this,n,s,!0,t).then(r=>r.slice(0,_e[T(this,M)]))}async getAddress20(t,n=0){if(T(this,M)!=="ecdsa")throw new Error("This method only supports `ecdsa` schema.");return await Y(this,F,we).call(this,t,n).then(s=>lt.dec(s.slice(_e[T(this,M)])))}async getPolkadotSigner(t,n,s=0){const r=await Y(this,F,we).call(this,n,s).then(c=>T(this,M)==="ed25519"?c.slice(0,_e[T(this,M)]):c.slice(_e[T(this,M)]));return{publicKey:r,signTx:async(c,a,d)=>{const i=Js(d,t),h=i.digest(),m=Qs(d);if(m.extrinsic.signedExtensions.find(({identifier:v})=>v===Ot)==null)throw new Error("No `CheckMetadataHash` sigExt found");const l=[],u=[];m.extrinsic.signedExtensions.map(({identifier:v})=>{if(v===Ot){l.push(Uint8Array.from([1])),u.push(B([Uint8Array.from([1]),h]));return}const I=a[v];if(!I)throw new Error(`Missing ${v} signed extension`);l.push(I.value),u.push(I.additionalSigned)});const y=B([c,...l,...u]),f=await Y(this,F,st).call(this,n,s,y,i.getProofForExtrinsicPayload(y));return nr(m,r,f,l,c)},signBytes:sr(async c=>(await Y(this,F,st).call(this,n,s,c)).slice(T(this,M)==="ed25519"?1:0))}}}be=new WeakMap;M=new WeakMap;Ie=new WeakMap;ve=new WeakMap;me=new WeakMap;Se=new WeakMap;F=new WeakSet;mt=async function(...e){for(;T(this,be).exchangeBusyPromise;)await T(this,be).exchangeBusyPromise;return await T(this,be).send(...e)};wt=async function(...e){return T(this,Se)||Z(this,Se,this.appInfo().then(({appName:t,appVersion:n})=>{if(t!=="Polkadot")throw new Error("Polkadot App is not opened");const s=n.split(".").map(r=>parseInt(r));if(s[0]<100||T(this,M)==="ecdsa"&&s[0]===100&&s[1]===0&&s[2]<12)throw new Error(`Polkadot App version ${n} not expected`)})),await T(this,Se),await Y(this,F,mt).call(this,...e)};we=async function(e,t,n,s){const r=`${T(this,M)}:${e}:${t}`;if(!n&&T(this,Ie).has(r))return T(this,Ie).get(r);if(s!=null&&(!Number.isInteger(s)||s<0||s>=65536))throw new Error(`Invalid ss58Prefix ${s}`);const o=Buffer.from(B([Dn(e,t),Uint8Array.from(ye.enc(s??er))])),c=Y(this,F,wt).call(this,Bn,nt.getAddress,n?Le.showAddress:Le.getAddress,Un[T(this,M)],o).then(a=>Uint8Array.from(a).slice(0,-2));return T(this,Ie).set(r,c),c};st=async function(e,t,n,s){const r=Dn(e,t),o=[];o.push(Buffer.from(B([r,ye.enc(n.length)])));const c=s==null?n:B([n,s]);let a=0;for(;a<c.length;){const i=Math.min(a+250,c.length);o.push(Buffer.from(c.slice(a,i))),a=i}let d;for(let i=0;i<o.length;i++)d=await Y(this,F,wt).call(this,Bn,s==null?nt.signRaw:nt.signTx,i===0?Le.init:i===o.length-1?Le.end:Le.continue,Un[T(this,M)],o[i]);if(d==null)throw null;return Uint8Array.from(d).slice(0,Zs[T(this,M)]+(T(this,M)==="ed25519"?1:0))};export{ar as LedgerSigner};
