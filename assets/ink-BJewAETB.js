import{w as tt,x as be,y as H,z as $,T as K,A as ie,C as Z,D,E as z,F as M,G as te,H as L,J as qe,K as U,L as Wt,V as w,S as g,O as q,R as Ae,_ as m,M as E,N as we,P as jt,Q as nt,U as Te,W as Nt,X as Pt,Y as zt,Z as Ft,$ as Kt,a0 as Gt,a1 as Xt,a2 as Yt,a3 as Jt,a4 as Qt,a5 as Zt}from"./index-ChSEz4ri.js";const De=(e,t)=>e.type==="array"&&e.len===t&&e.value.type==="primitive"&&e.value.value==="u8",G={type:"void"},en=(e,t=()=>null)=>{const n=new Map,s=new Set,o=r=>f=>{let l=n.get(f);if(l)return l;if(s.has(f)){const p={id:f};return n.set(f,p),p}s.add(f);const a=r(f);return l=n.get(f),l?Object.assign(l,a):(l={id:f,...a},n.set(f,l)),s.delete(f),l};let d=!0,u=!0;const i=o(r=>{const f=t(e[r]);if(f)return f;const{def:l,path:a,params:p}=e[r];if(l.tag==="composite"){if(l.value.length===0)return G;if(l.value.length===1){const v=i(l.value[0].type);return d&&a.at(-1)==="AccountId32"&&De(v,32)?(d=!1,{type:"AccountId32"}):u&&a.at(-1)==="AccountId20"&&De(v,20)?(u=!1,{type:"AccountId20"}):v}return y(l.value)}if(l.tag==="variant"){if(a.length===1&&a[0]==="Option"&&p.length===1&&p[0].name==="T"){const _=i(p[0].type);return _.type==="void"?{type:"primitive",value:"bool"}:{type:"option",value:_}}if(a.length===1&&a[0]==="Result"&&p.length===2&&p[0].name==="T"&&p[1].name==="E")return{type:"result",value:{ok:i(p[0].type),ko:i(p[1].type)}};if(l.value.length===0)return G;const v={},b={};return l.value.forEach(_=>{const fe=_.name;if(b[fe]=_.docs,_.fields.length===0){v[fe]={...G,idx:_.index};return}if(_.fields.length===1&&!_.fields[0].name){v[fe]={type:"lookupEntry",value:i(_.fields[0].type),idx:_.index};return}v[fe]={...y(_.fields),idx:_.index}}),{type:"enum",value:v,innerDocs:b}}if(l.tag==="sequence")return{type:"sequence",value:i(l.value)};if(l.tag==="array"){const{len:v}=l.value,b=i(l.value.type);return!v||b.type==="void"?G:v>1?{type:"array",value:b,len:l.value.len}:b}if(l.tag==="tuple")return l.value.length===0?G:l.value.length>1?c(l.value.map(v=>i(v)),l.value.map(v=>e[v].docs)):i(l.value[0]);if(l.tag==="primitive")return{type:"primitive",value:l.value.tag};if(l.tag==="compact"){const v=i(l.value);return v.type==="void"?G:{type:"compact",isBig:Number(v.value.slice(1))>32,size:v.value}}return{type:l.tag,isLSB:(e[l.value.bitOrderType].path.at(-1)??"LSB").toUpperCase().startsWith("LSB")}}),y=r=>{let f=!0;const l={},a={};return r.forEach((p,v)=>{f=f&&!!p.name;const b=p.name||v,_=i(p.type);_.type!=="void"&&(l[b]=_,a[b]=p.docs)}),f?{type:"struct",value:l,innerDocs:a}:c(Object.values(l),Object.values(a))},c=(r,f)=>{if(r.every(l=>l.id===r[0].id)&&f.every(l=>!l.length)){const[l]=r;return l.type==="void"?G:{type:"array",value:r[0],len:r.length}}return{type:"tuple",value:r,innerDocs:f}};return i},tn=e=>en(e),st=new TextEncoder().encode("SS58PRE"),$e=2,rt=e=>{try{const t=tt.decode(e),n=t.subarray(0,t[0]&64?2:1),s=t.subarray(n.length,t.length-$e),o=t.subarray(n.length+s.length),d=be(Uint8Array.of(...st,...n,...s),{dkLen:64}).subarray(0,$e);return o[0]===d[0]&&o[1]===d[1]?{isValid:!0,ss58Format:nn(n),publicKey:s.slice()}:{isValid:!1}}catch{return{isValid:!1}}},nn=e=>{const t=new DataView(e.buffer,e.byteOffset,e.byteLength);return t.byteLength===1?t.getUint8(0):t.getUint16(0)},sn=e=>{let t={},n=0,s=0;const o=()=>{n===s?(t={},n=s=0):(s=n,setTimeout(o,0))};return d=>{var u,i;++n===1&&o();let y=t;const c=d.length-1;for(let r=0;r<=c;r++)y=y[u=d[r]]||(y[u]={});return y[i=d[c]]||(y[i]=e(d))}},ot=e=>{const t=e<64?Uint8Array.of(e):Uint8Array.of((e&252)>>2|64,e>>8|(e&3)<<6);return sn(n=>{const s=be(Uint8Array.of(...st,...t,...n),{dkLen:64}).subarray(0,$e);return tt.encode(Uint8Array.of(...t,...n,...s))})};function rn(e,t){return n=>{const s=rt(n);if(!s.isValid)throw new Error("Invalid checksum");const{publicKey:o}=s;if(o.length!==e)throw new Error("Invalid public key length");return o}}const Le=(e=42,t=32)=>H($(t),rn(t),ot(e));var on=Object.defineProperty,ct=e=>{throw TypeError(e)},cn=(e,t,n)=>t in e?on(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,se=(e,t,n)=>cn(e,typeof t!="symbol"?t+"":t,n),at=(e,t,n)=>t.has(e)||ct("Cannot "+n),W=(e,t,n)=>(at(e,t,"read from private field"),n?n.call(e):t.get(e)),re=(e,t,n)=>t.has(e)?ct("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,n),X=(e,t,n,s)=>(at(e,t,"write to private field"),t.set(e,n),n),j,ce,he,pe,ve;const an=new TextEncoder,ln=new TextDecoder,un=K(Z,$(1/0))[1];class R{constructor(t,n=!1){if(re(this,j),re(this,ce,null),re(this,he,null),re(this,pe,null),re(this,ve,null),se(this,"asText",()=>W(this,ve)??X(this,ve,ln.decode(W(this,j)))),se(this,"asHex",()=>W(this,he)??X(this,he,D(W(this,j)))),se(this,"asOpaqueHex",()=>W(this,pe)??X(this,pe,D(this.asBytes()))),se(this,"asBytes",()=>W(this,j)),se(this,"asOpaqueBytes",()=>W(this,ce)??X(this,ce,z([W(this,j),Z[0](W(this,j).length)]))),n){try{const[s,o]=un(t);if(s===o.length){X(this,j,o),X(this,ce,t);return}}catch{}throw new Error("Invalid opaque bytes")}else X(this,j,t)}static fromText(t){return new this(an.encode(t))}static fromHex(t){return new this(ie(t))}static fromOpaqueHex(t){return new this(ie(t),!0)}static fromBytes(t){return new this(t)}static fromOpaqueBytes(t){return new this(t,!0)}}j=new WeakMap;ce=new WeakMap;he=new WeakMap;pe=new WeakMap;ve=new WeakMap;const[dn]=Le();class it extends R{constructor(t){super(t)}static fromArray(t){return new this(new Uint8Array(t))}static fromAccountId32(t){return new this(dn(t))}}const lt=e=>{const t=$.enc(e);return n=>t(n.asBytes())},ut=e=>{const t=$.dec(e),n=e==null?R:it;return s=>n.fromBytes(t(s))},le=e=>M(lt(e),ut(e));le.enc=lt;le.dec=ut;const h=H(Z,e=>e,Number),dt=H(Z,e=>e,BigInt),yn=te(e=>{const t=h.dec(e),n=Math.ceil(t/8);return{bytes:$(n).dec(e),bitsLen:t}}),fn=e=>{if(e.bitsLen>e.bytes.length*8)throw new Error(`Not enough bytes. (bitsLen:${e.bitsLen}, bytesLen:${e.bytes.length})`);const t=h.enc(e.bitsLen),n=new Uint8Array(e.bytes.length+t.length);return n.set(t,0),n.set(e.bytes,t.length),n},hn=M(fn,yn),pn=H(L,e=>e.charCodeAt(0),String.fromCharCode),yt=e=>{const t=$.enc(e);return n=>t(ie(n))},ft=e=>{const t=$.dec(e);return n=>D(t(n))},A=e=>M(yt(e),ft(e));A.enc=yt;A.dec=ft;const ht=new TextEncoder,vn=new TextDecoder,mn=e=>H($(e),t=>ht.encode(t),t=>vn.decode(t)),pt=e=>{let t=n=>{const s=e();return t=s,s(n)};return n=>t(n)},vt=e=>{let t=n=>{const s=e(),o=s;return t=s,o(n)};return n=>t(n)},mt=e=>M(pt(()=>e().enc),vt(()=>e().dec)),gn={is(e,t){return e.type===t},as(e,t){if(t!==e.type)throw new Error(`Enum.as(enum, ${t}) used with actual type ${e.type}`);return e}},Oe=Object.assign((e,t)=>({type:e,value:t}),gn),bn=new Proxy({},{get(e,t){return n=>Oe(t,n)}}),B=(e,t)=>{const n=e;return n.inner=t,n},gt=(...e)=>{const t=U.enc(...e);return B(n=>t({tag:n.type,value:n.value}),e[0])},bt=(...e)=>{const t=U.dec(...e);return B(n=>{const{tag:s,value:o}=t(n);return Oe(s,o)},e[0])},Q=(e,...t)=>B(M(gt(qe(e,([n])=>n),...t),bt(qe(e,([,n])=>n),...t)),e);Q.enc=gt;Q.dec=bt;const Ee=(e,...t)=>B(U(e,...t),e);Ee.enc=(e,...t)=>B(U.enc(e,...t),e);Ee.dec=(e,...t)=>B(U.dec(e,...t),e);const wt=Wt,Re=e=>{const t=e.slice(2),n=D(wt(ht.encode(t))).slice(2),s=new Array(40);for(let o=0;o<40;o++){const d=parseInt(n[o],16),u=t[o];s[o]=d>7?u.toUpperCase():u}return`0x${s.join("")}`},wn=$(20)[1],Et=M(e=>{const t=ie(e);if(t.length!==20)throw new Error(`Invalid length found on EthAddress(${e})`);const n=D(t);if(e===n||e===n.toUpperCase())return t;if(Re(n)!==e)throw new Error(`Invalid checksum found on EthAddress(${e})`);return t},te(e=>Re(D(wn(e))))),S=e=>B(g(e),e);S.enc=e=>B(g.enc(e),e);S.dec=e=>B(g.dec(e),e);const ue=(...e)=>B(K(...e),e);ue.enc=(...e)=>B(K.enc(...e),e);ue.dec=(...e)=>B(K.dec(...e),e);const F=(e,...t)=>B(w(e,...t),e);F.enc=(e,...t)=>B(w.enc(e,...t),e);F.dec=(e,...t)=>B(w.dec(e,...t),e);const xe=(e,t)=>B(Ae(e,t),{ok:e,ko:t});xe.enc=(e,t)=>B(Ae.enc(e,t),{ok:e,ko:t});xe.dec=(e,t)=>B(Ae.dec(e,t),{ok:e,ko:t});const ne=e=>B(q(e),e);ne.enc=e=>B(q.enc(e),e);ne.dec=e=>B(q.dec(e),e);const xt=(e=!0)=>te(t=>{const n=h.dec(t),s=Math.ceil(n/8),o=$(s).dec(t),d=new Array(n);let u=0;return o.forEach(i=>{for(let y=0;y<8&&u<n;y++){const c=e?y:7-y;d[u++]=i>>c&1}}),d}),Bt=(e=!0)=>t=>{const n=h.enc(t.length),s=Math.ceil(t.length/8),o=new Uint8Array(s);for(let d=0;d<s;d++){let u=d*8,i=0;for(let y=0;y<8&&u<t.length;y++,u++)i|=t[u]<<(e?y:7-y);o[d]=i}return z([n,o])},Be=e=>M(Bt(e),xt(e));Be.enc=Bt;Be.dec=xt;const We=new TextEncoder,je=new TextDecoder,En=H($(4),We.encode.bind(We),je.decode.bind(je)),Ie=S({engine:En,payload:A()}),xn=Q({other:$(),consensus:Ie,seal:Ie,preRuntime:Ie,runtimeUpdated:m},[0,4,5,6,8]),ke=A(32),Bn=S({parentHash:ke,number:h,stateRoot:ke,extrinsicRoot:ke,digests:F(xn)}),V=w(E),Ne=q(E),_n=U({bool:m,char:m,str:m,u8:m,u16:m,u32:m,u64:m,u128:m,u256:m,i8:m,i16:m,i32:m,i64:m,i128:m,i256:m}),_t=w(g({name:Ne,type:h,typeName:Ne,docs:V})),In=g({len:we,type:h}),kn=g({bitStoreType:h,bitOrderType:h}),Sn=w(g({name:E,fields:_t,index:L,docs:V})),Cn=U({composite:_t,variant:Sn,sequence:h,array:In,tuple:w(h),primitive:_n,compact:h,bitSequence:kn}),$n=g({name:E,type:q(h)}),An=w($n),Tn=g({id:h,path:V,params:An,def:Cn,docs:V}),de=w(Tn),ee=U({NotDeprecated:m,DeprecatedWithoutNote:m,Deprecated:g({note:E,since:q(E)})}),Ln=w(g({index:L,deprecation:U({DeprecatedWithoutNote:m,Deprecated:g({note:E,since:q(E)})},[1,2])})),Ve={name:E,inputs:w(g({name:E,type:h})),output:h,docs:V},On=g({name:E,methods:w(g(Ve)),docs:V}),Vn=g({name:E,methods:w(g({...Ve,deprecationInfo:ee})),docs:V,version:h,deprecationInfo:ee}),Hn=g({id:A(32),...Ve,deprecationInfo:ee}),Mn=U({Blake2128:m,Blake2256:m,Blake2128Concat:m,Twox128:m,Twox256:m,Twox64Concat:m,Identity:m}),Un=w(Mn),qn=g({hashers:Un,key:h,value:h}),It={name:E,modifier:L,type:U({plain:h,map:qn}),fallback:A(),docs:V},Se=q(h),kt={name:E,storage:q(g({prefix:E,items:w(g(It))})),calls:Se,events:Se,constants:w(g({name:E,type:h,value:A(),docs:V})),errors:Se,index:L},Dn={...kt,docs:V},Ce=q(g({type:h,deprecationInfo:Ln})),Rn={name:E,storage:q(g({prefix:E,items:w(g({...It,deprecationInfo:ee}))})),calls:Ce,events:Ce,constants:w(g({name:E,type:h,value:A(),docs:V,deprecationInfo:ee})),errors:Ce,associatedTypes:w(g({name:E,type:h,docs:V})),viewFns:w(Hn),index:L,docs:V,deprecationInfo:ee},Wn=new Uint8Array,Pe=e=>M(()=>Wn,()=>e),jn=g({type:h,version:L,signedExtensions:w(g({identifier:E,type:h,additionalSigned:h}))}),St=g({lookup:de,pallets:w(g({...kt,docs:Pe([])})),extrinsic:jn,type:h,apis:Pe([])}),Nn=g({version:L,address:h,call:h,signature:h,extra:h,signedExtensions:w(g({identifier:E,type:h,additionalSigned:h}))}),Ct=g({lookup:de,pallets:w(g(Dn)),extrinsic:Nn,type:h,apis:w(On),outerEnums:g({call:h,event:h,error:h}),custom:w(K(E,g({type:h,value:A()})))}),Pn=g({version:w(L),address:h,call:h,signature:h,signedExtensionsByVersion:w(K(L,w(h))),signedExtensions:w(g({identifier:E,type:h,additionalSigned:h}))}),$t=g({lookup:de,pallets:w(g(Rn)),extrinsic:Pn,apis:w(Vn),outerEnums:g({call:h,event:h,error:h}),custom:w(K(E,g({type:h,value:A()})))}),ze=()=>{throw new Error("Unsupported metadata version!")},T=M(ze,ze),ae=g({magicNumber:we,metadata:U({v0:T,v1:T,v2:T,v3:T,v4:T,v5:T,v6:T,v7:T,v8:T,v9:T,v10:T,v11:T,v12:T,v13:T,v14:St,v15:Ct,v16:$t})}),He=$(),zn=q(He),Fn=K(Z,He),Kn=e=>{try{return ae.dec(e)}catch{}try{return ae.dec(zn.dec(e))}catch{}try{return ae.dec(He.dec(e))}catch{}try{return ae.dec(Fn.dec(e)[1])}catch{}throw null},Gn=e=>{if("magicNumber"in e&&(e=e.metadata),"tag"in e){if(e.tag!=="v14"&&e.tag!=="v15"&&e.tag!=="v16")throw new Error("Only metadata 14, 15, and 16 are supported");e=e.value}if("signedExtensionsByVersion"in e.extrinsic)return{version:16,...e};if("custom"in e){const{lookup:o,extrinsic:d,custom:u,apis:i,pallets:y,outerEnums:c}=e;return{version:15,lookup:o,pallets:y.map(r=>({...r,calls:r.calls!=null?{type:r.calls}:void 0,events:r.events!=null?{type:r.events}:void 0,errors:r.errors!=null?{type:r.errors}:void 0,viewFns:[],associatedTypes:[]})),extrinsic:{...d,version:[d.version]},apis:i,outerEnums:c,custom:u}}const{lookup:t,extrinsic:n,pallets:s}=e;return{version:14,lookup:t,pallets:s.map(o=>({...o,calls:o.calls!=null?{type:o.calls}:void 0,events:o.events!=null?{type:o.events}:void 0,errors:o.errors!=null?{type:o.errors}:void 0,viewFns:[],associatedTypes:[]})),extrinsic:{...n,version:[n.version]},apis:[]}},Y={bare:0,0:"bare",general:1,1:"general",signed:2,2:"signed"},Xn=H(L,({version:e,type:t})=>e+(Y[t]<<6),e=>{const t=e&63,n=e>>6;if(t===4&&(n===Y.bare||n===Y.signed))return{version:t,type:Y[n]};if(t===5&&(n===Y.bare||n===Y.general))return{version:t,type:Y[n]};throw new Error(`ExtrinsicFormat ${e} not valid`)}),Yn={dkLen:32},_e=e=>be(e,Yn),Jn={dkLen:16},Me=e=>be(e,Jn),At=e=>z([Me(e),e]),Qn={dkLen:32},Tt=e=>jt(e,Qn),Zn=e=>z([Tt(e),e]),Lt=e=>e,J=(e,t,n,s)=>new DataView(new Uint16Array([e,t,n,s]).buffer).getBigUint64(0,!0),Ue=2n**64n-1n,C=(e,t)=>e<<t&Ue|e>>64n-t,x=(e,t)=>e*t&Ue,I=(e,t)=>e+t&Ue,k=11400714785074694791n,O=14029467366897019727n,Fe=1609587929392839161n,oe=9650029242287828579n,Ke=2870177450012600261n;function P(e,t=0n){let n=I(I(t,k),O),s=I(t,O),o=t,d=t-k,u=e.length,i=0,y=null;(function(){let a=0,p=a+u;if(u){if(y=new Uint8Array(32),u<32){y.set(e.subarray(0,u),i),i+=u;return}if(a<=p-32){const v=p-32;do{let b;b=J(e[a+1]<<8|e[a],e[a+3]<<8|e[a+2],e[a+5]<<8|e[a+4],e[a+7]<<8|e[a+6]),n=x(C(I(n,x(b,O)),31n),k),a+=8,b=J(e[a+1]<<8|e[a],e[a+3]<<8|e[a+2],e[a+5]<<8|e[a+4],e[a+7]<<8|e[a+6]),s=x(C(I(s,x(b,O)),31n),k),a+=8,b=J(e[a+1]<<8|e[a],e[a+3]<<8|e[a+2],e[a+5]<<8|e[a+4],e[a+7]<<8|e[a+6]),o=x(C(I(o,x(b,O)),31n),k),a+=8,b=J(e[a+1]<<8|e[a],e[a+3]<<8|e[a+2],e[a+5]<<8|e[a+4],e[a+7]<<8|e[a+6]),d=x(C(I(d,x(b,O)),31n),k),a+=8}while(a<=v)}a<p&&(y.set(e.subarray(a,p),i),i=p-a)}})(),e=y||e;let c,r=0;for(u>=32?(c=C(n,1n),c=I(c,C(s,7n)),c=I(c,C(o,12n)),c=I(c,C(d,18n)),n=x(C(x(n,O),31n),k),c=c^n,c=I(x(c,k),oe),s=x(C(x(s,O),31n),k),c=c^s,c=I(x(c,k),oe),o=x(C(x(o,O),31n),k),c=c^o,c=I(x(c,k),oe),d=x(C(x(d,O),31n),k),c=c^d,c=I(x(c,k),oe)):c=I(t,Ke),c=I(c,BigInt(u));r<=i-8;){let l=J(e[r+1]<<8|e[r],e[r+3]<<8|e[r+2],e[r+5]<<8|e[r+4],e[r+7]<<8|e[r+6]);l=x(C(x(l,O),31n),k),c=I(x(C(c^l,27n),k),oe),r+=8}if(r+4<=i){let l=x(J(e[r+1]<<8|e[r],e[r+3]<<8|e[r+2],0,0),k);c=I(x(C(c^l,23n),O),Fe),r+=4}for(;r<i;){const l=x(J(e[r++],0,0,0),Ke);c=x(C(c^l,11n),k)}let f=c>>33n;return c=x(c^f,O),f=c>>29n,c=x(c^f,Fe),f=c>>32n,c^=f,c}const me=e=>{const t=new Uint8Array(16),n=new DataView(t.buffer);return n.setBigUint64(0,P(e),!0),n.setBigUint64(8,P(e,1n),!0),t},Ot=e=>{const t=new Uint8Array(32),n=new DataView(t.buffer);return n.setBigUint64(0,P(e),!0),n.setBigUint64(8,P(e,1n),!0),n.setBigUint64(16,P(e,2n),!0),n.setBigUint64(24,P(e,3n),!0),t},Vt=e=>z([nt.enc(P(e)),e]),Ge=new TextEncoder,es=new Map([[Lt,0],[Vt,8],[At,16],[Me,-16],[_e,-32],[me,-16],[Ot,-32]]),ts=e=>{const t=me(Ge.encode(e));return(n,...s)=>{const o=z([t,me(Ge.encode(n))]),d=D(o),u=c=>{if(!c.startsWith(d))throw new Error(`key does not match this storage (${e}.${n})`);if(s.length===0)return[];const r=ie(c.slice(d.length)),f=new Array(s.length);for(let l=0,a=0;l<s.length;l++){const[p,v]=s[l],b=es.get(v);if(b==null)throw new Error("Unknown hasher");if(b<0){const _=b*-1;f[l]=D(r.slice(a,a+_)),a+=_}else a+=b,f[l]=p.dec(r.slice(a)),a+=p.enc(f[l]).length}return f},i=s.map(([{enc:c},r])=>f=>r(c(f)));return{enc:(...c)=>D(z([o,...c.map((r,f)=>i[f](r))])),dec:u}}},ns=R.fromText("modlpy/utilisuba").asBytes(),ss=({threshold:e,signatories:t})=>{const n=Ht(t),s=z([ns,Z.enc(n.length),...n,Te.enc(e)]);return _e(s)},Ht=e=>e.slice().sort((t,n)=>{for(let s=0;;s++){const o=s>=t.length,d=s>=n.length;if(o&&d)return 0;if(o)return-1;if(d)return 1;if(t[s]!==n[s])return t[s]>n[s]?1:-1}}),N={Leaf:"Leaf",Branch:"Branch",BranchWithVal:"BranchWithVal",LeafWithHash:"LeafWithHash",BranchWithHash:"BranchWithHash",Empty:"Empty",Reserved:"Reserved"},Xe=A().dec,rs=A(1/0).dec,os=A(32).dec,Ye=L.dec,cs=e=>{const t=Ye(e);let n=6;const s=t>>n,o=s?s===1?N.Leaf:s===2?N.Branch:N.BranchWithVal:t>>--n?N.LeafWithHash:t>>--n?N.BranchWithHash:t?N.Reserved:N.Empty;let d=t&255>>8-n;if(d===2**n-1){let u;do d+=u=Ye(e);while(u===255)}return{type:o,partialKey:A(Math.ceil(d/2)).dec(e).slice(d%2?3:2)}},Mt=te(e=>{const t=cs(e),{type:n}=t;if(n==="Empty"||n==="Reserved")return t;if(n==="Leaf"||n==="LeafWithHash")return{...t,value:rs(e)};const s=Te.dec(e),o=[];for(let i=0;i<16;i++)s>>i&1&&o.push(i.toString(16));let d=null;n==="BranchWithVal"&&(d=Xe(e)),n==="BranchWithHash"&&(d=os(e));const u={...t,children:Object.fromEntries(o.map(i=>[i,Xe(e)]))};return d!==null&&(u.value=d),u}),Ut=e=>te(t=>{const n=D(e(new Uint8Array(t.buffer)));try{return{hash:n,...Mt(t)}}catch{return{type:"Raw",hash:n,value:""}}}),as=(e,t=_e)=>{const n=e.map(Ut(t)),s=Object.fromEntries(n.map(i=>[i.hash,i])),o=n.map(i=>i.hash),d=new Set(o),u=i=>{if(i.value)return;const y=e[o.indexOf(i.hash)];i.value=typeof y=="string"?y:D(y)};return n.forEach(i=>{if("children"in i&&Object.values(i.children).forEach(y=>{const c=s[y];c&&(c.parent=i.hash,d.delete(y))}),i.type==="BranchWithHash"||i.type==="LeafWithHash"){const y=i.value,c=s[y];if(!c)return;d.delete(y),c.type!=="Raw"&&(Object.keys(c).forEach(r=>delete c[r]),c.type="Raw",c.hash=y),c.parent=i.hash,u(c)}i.type==="Raw"&&u(i)}),d.size===1?{rootHash:d.values().next().value,proofs:s}:null},is=Object.freeze(Object.defineProperty({__proto__:null,AccountId:Le,Bin:le,Binary:R,BitSeq:Be,Blake2128:Me,Blake2128Concat:At,Blake2256:_e,Blake3256:Tt,Blake3256Concat:Zn,Bytes:$,Enum:Oe,FixedSizeBinary:it,Hex:A,Identity:Lt,Keccak256:wt,Option:ne,Result:xe,ScaleEnum:Ee,Self:mt,Storage:ts,Struct:S,TrieNodeHeaders:N,TrieNodeWithHash:Ut,Tuple:ue,Twox128:me,Twox256:Ot,Twox64Concat:Vt,Variant:Q,Vector:F,_Enum:bn,_void:m,bitSequence:hn,blockHeader:Bn,bool:Nt,char:pn,compact:Z,compactBn:dt,compactNumber:h,createCodec:M,createDecoder:te,decAnyMetadata:Kn,enhanceCodec:H,enhanceDecoder:Pt,enhanceEncoder:zt,ethAccount:Et,extrinsicFormat:Xn,fixedStr:mn,fromBufferToBase58:ot,getMultisigAccountId:ss,getSs58AddressInfo:rt,h64:P,i128:Ft,i16:Kt,i256:Gt,i32:Xt,i64:Yt,i8:Jt,metadata:ae,selfDecoder:vt,selfEncoder:pt,sortMultisigSignatories:Ht,str:E,trieNodeDec:Mt,u128:Qt,u16:Te,u256:Zt,u32:we,u64:nt,u8:L,unifyMetadata:Gn,v14:St,v14Lookup:de,v15:Ct,v16:$t,validateProofs:as},Symbol.toStringTag,{value:"Module"})),ls=(e,t,n)=>(s,o,d,...u)=>{const{id:i}=s;if(o.has(i))return o.get(i);if(d.has(i)){const c=t(()=>o.get(i),s,...u);return o.set(i,c),c}d.add(i);let y=e(s,o,d,...u);return d.delete(i),o.has(i)&&(y=n(y,o.get(i),s,...u)),o.set(i,y),y},us=le(),ds=(e,t,n,s)=>{if(e.type==="primitive")return is[e.value];if(e.type==="void")return m;if(e.type==="AccountId32")return s;if(e.type==="AccountId20")return Et;if(e.type==="compact")return e.isBig?dt:h;if(e.type==="bitSequence")return Be(e.isLSB);const o=a=>qt(a,t,n,s),d=(a,p)=>{const v=o(a);return p?F(v,p):F(v)},u=a=>ue(...a.map(o)),i=a=>{const p=Object.fromEntries(Object.entries(a).map(([v,b])=>[v,o(b)]));return S(p)};if(e.type==="sequence"&&e.value.type==="primitive"&&e.value.value==="u8")return us;if(e.type==="array")return e.value.type==="primitive"&&e.value.value==="u8"?le(e.len):d(e.value,e.len);if(e.type==="sequence")return d(e.value);if(e.type==="tuple")return u(e.value);if(e.type==="struct")return i(e.value);if(e.type==="option")return ne(o(e.value));if(e.type==="result")return xe(o(e.value.ok),o(e.value.ko));const y=Object.values(e.value).map(a=>{switch(a.type){case"void":return m;case"lookupEntry":return o(a.value);case"tuple":return u(a.value);case"struct":return i(a.value);case"array":return d(a.value,a.len)}}),c=Object.fromEntries(Object.keys(e.value).map((a,p)=>[a,y[p]])),r=Object.values(e.value).map(a=>a.idx),l=r.every((a,p)=>a===p)?Q(c):Q(c,r);return e.byteLength?fs(l,e.byteLength):l},qt=ls(ds,mt,e=>e),ys=(e,t=Le())=>{const n=new Map,s=o=>qt(e(o),n,new Set,t);return o=>s(o)},fs=(e,t)=>{const n=$(t);return M(s=>n.enc(e.enc(s)),s=>e.dec(n.dec(s)))},hs=e=>{const{metadata:t}=e,n=ys(e),s=(r="")=>{const f=e.storage[r];if(!f)throw new Error(`Storage entry ${r||"{root}"} not found`);const l=f.key==null?m:n(f.key);return{key:Je(l,f.keyPrefix),value:n(f.typeId)}},o=r=>{const f=S(Object.fromEntries(r.args.map(l=>[l.label,n(l.type.type)])));return{call:Je(f,r.selector),value:n(r.returnType.type)}},d=r=>{const f=t.spec.constructors.find(l=>l.label===r);if(!f)throw new Error(`Constructor ${r} not found`);return o(f)},u=r=>{const f=t.spec.messages.find(l=>l.label===r);if(!f)throw new Error(`Message ${r} not found`);return o(f)},i=r=>S(Object.fromEntries(r.args.map(f=>[f.label,n(f.type.type)])));return{buildConstructor:d,buildMessage:u,buildStorage:s,buildEvents:()=>Q(Object.fromEntries(t.spec.events.map(r=>[r.label,i(r)]))),buildEvent:r=>{const f=t.spec.events,l=(p,v)=>H(p,b=>b.value,b=>({type:v,value:b}));if(r){const p=f.find(v=>v.signature_topic===r);return p?l(i(p),p.label):null}const a=f.filter(p=>p.signature_topic===r);return a.length?ps(a.map(p=>l(i(p),p.label))):null}}},Je=(e,t)=>{const n=R.fromHex(t).asBytes(),s=ue($(n.length),e);return H(s,o=>[n,o],([,o])=>o)},ps=e=>M(t=>{for(const n of e)try{n.enc(t)}catch{}throw new Error("Unable to encode")},t=>{for(const n of e)try{n.dec(t)}catch{}throw new Error("Unable to decode")}),Dt=e=>H(Ee(e),t=>{if(typeof t=="string")return{tag:t,value:void 0};const[n,s]=Object.entries(t)[0];return{tag:n,value:s}},t=>({[t.tag]:t.value})),ye=(e,t)=>H(F(e,t),n=>n??[],n=>n),Qe=ne(E),ge=ye(E),vs=Dt({bool:m,char:m,str:m,u8:m,u16:m,u32:m,u64:m,u128:m,u256:m,i8:m,i16:m,i32:m,i64:m,i128:m,i256:m}),Rt=ye(S({name:Qe,type:h,typeName:Qe,docs:ge})),ms=S({len:we,type:h}),gs=S({bitStoreType:h,bitOrderType:h}),bs=ye(S({name:E,fields:Rt,index:L,docs:ge})),ws=Dt({composite:S({fields:Rt}),variant:S({variants:bs}),sequence:S({type:h}),array:ms,tuple:F(h),primitive:vs,compact:S({type:h}),bitSequence:gs}),Es=S({name:E,type:ne(h)}),xs=ye(Es),Bs=S({id:h,path:ge,params:xs,def:ws,docs:ge}),_s=H(Bs,e=>({id:e.id,path:e.type.path,params:e.type.params??[],def:e.type.def,docs:[]}),e=>({id:e.id,type:{def:e.def,path:e.path,params:e.params}})),Is=ye(_s),ks=e=>{const t=Is.enc(e.types),n=de.dec(t),s=e.spec.environment.accountId.type,o=n.find(i=>i.id===s);o&&(o.path=["AccountId32"]);const d=Ss(e,n),u=tn(n);return Object.assign(u,{metadata:e,lookup:n,storage:d})};function Ss(e,t){const n={},s=(o,d=[])=>{function u(y){const c=t.length;return t[c]={id:c,docs:[],def:y,params:[],path:[]},c}if("root"in o){const y=Number(e.version)===4?R.fromBytes(R.fromHex(o.root.root_key).asBytes().reverse()).asHex():o.root.root_key,c=s(o.root.layout,d);if(o.root.ty!=null){let r=function(f,l){const a=e.types[f].type,p="composite"in a.def?new Map((a.def.composite.fields??[]).map(b=>[b.name,b.type])):null,v=new Map((a.params??[]).map(b=>[b.name,b.type]));if(v.size===2&&v.has("V")&&p&&p.size===2&&p.has("len")&&p.has("elements")){r(p.get("len"),[...l,"len"]),r(p.get("elements"),l);return}else v.size===3&&v.has("K")&&v.has("V")?n[l.join(".")]={keyPrefix:y,key:v.get("K"),typeId:v.get("V")}:v.size===2&&v.has("V")&&(n[l.join(".")]={keyPrefix:y,key:null,typeId:v.get("V")})};r(o.root.ty,d)}return n[d.join(".")]||(n[d.join(".")]={keyPrefix:y,key:null,typeId:c}),u({tag:"composite",value:[]})}if("leaf"in o)return o.leaf.ty;if("hash"in o)throw new Error("HashLayout not implemented");if("array"in o){const y=s(o.array.layout,d);return y==null?null:u({tag:"array",value:{len:o.array.len,type:y}})}if("struct"in o){const y=o.struct.fields.map(c=>({name:c.name,type:s(c.layout,[...d,c.name]),typeName:void 0,docs:[]})).filter(c=>c.type!=null);return u({tag:"composite",value:y})}const i=Object.values(o.enum.variants).map((y,c)=>({name:y.name,fields:y.fields.map(r=>({name:r.name,type:s(r.layout,[...d,y.name,r.name]),typeName:void 0,docs:[]})).filter(r=>r.type!==null),index:c,docs:[]}));return u({tag:"variant",value:i})};return s(e.storage),n}const Ls=e=>{if(!e.metadata)throw new Error("Ink client needs the contract metadata");const t=ks(e.metadata),n=hs(t),s=et(n.buildConstructor),o=et(n.buildMessage),d=c=>{const r=t.metadata.spec.constructors.find(f=>f.label===c);if(!r)throw new Error(`Constructor ${c} not found`);return r},u=c=>{const r=t.metadata.spec.messages.find(f=>f.label===c);if(!r)throw new Error(`Message ${c} not found`);return r},i=t.metadata.spec.constructors.find(c=>c.default)?.label,y=t.metadata.spec.messages.find(c=>c.default)?.label;return{constructor:c=>({attributes:Ze(d(c)),...s(c)}),defaultConstructor:i,message:c=>({attributes:Ze(u(c)),...o(c)}),defaultMessage:y,storage:Cs(n.buildStorage),event:Number(t.metadata.version)===4?$s(n.buildEvents):As(t,n.buildEvent)}},Ze=e=>({payable:e.payable,default:e.default,mutates:"mutates"in e?e.mutates:!0}),et=e=>t=>{const n=e(t);return{encode:s=>R.fromBytes(n.call.enc(s||{})),decode:s=>n.value.dec(s.data.asBytes())}},Cs=e=>t=>{const n=e(t);return{encode:s=>R.fromBytes(n.key.enc(s)),decode:s=>n.value.dec(s.asBytes())}},$s=e=>{const t=s=>e().dec(s.data.asBytes());return{decode:t,filter:(s,o=[])=>o.map(u=>"event"in u?u.event:u).filter(u=>u.type==="Contracts"&&u.value.type==="ContractEmitted"&&u.value.value.contract===s).map(u=>{try{return t(u.value.value)}catch(i){throw console.error(`Contract ${s} emitted an incompatible event`,u.value.value),i}})}},As=(e,t)=>{const n=new Set(e.metadata.spec.events.map(u=>u.signature_topic).filter(u=>u!=null)),s=e.metadata.spec.events.some(u=>u.signature_topic==null),o=(u,i)=>{if(i!=null){if(!n.has(i))throw new Error(`Event with signature topic ${u} not found`);return t(i).dec(u.data.asBytes())}if(!s)throw new Error("Event signature topic required");return t(void 0).dec(u.data.asBytes())};return{decode:o,filter:(u,i=[])=>{const y=r=>(r instanceof R?r.asHex():r)===u;return i.map(r=>"event"in r?r:{event:r,topics:r.topics}).filter(r=>(r.event.type==="Contracts"||r.event.type==="Revive")&&r.event.value.type==="ContractEmitted"&&y(r.event.value.value.contract)).map(r=>{const l=[...r.topics,...r.event.value?.value?.topics??[]].map(a=>a.asHex()).find(a=>n.has(a));try{return o(r.event.value.value,l)}catch{return null}}).filter(r=>r!==null)}}};export{Ls as getInkClient};
